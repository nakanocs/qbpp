<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>QUBO++ Documentation - QUBO++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Minima テーマの main.css（ハイライト含む） -->
  <link rel="stylesheet" href="/assets/main.css">

  <!-- 自前のナビ用 CSS -->
  <link rel="stylesheet" href="/assets/custom.css">

  <!-- ここに MathJax 関連をまとめて入れる -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


<body>
  <div style="display:flex; align-items:flex-start; gap:2rem; padding:1rem;">

    <!-- 左ナビ（全ページ共通） -->
    <nav style="min-width:220px; position:sticky; top:1rem; padding-right:1rem; border-right:1px solid #ddd;">
      <h2>QUBO++<br> Information</h2>
      <ul class="nav-large" style="list-style:none; padding-left:0;">
        <li><a href="https://github.com/nakanocs/qbpp/releases"><strong>Releases</strong></a></li>
        <li><a href="/DOCUMENT"><strong>Document</strong></a></li>
        <li><a href="/tutorial/TUTORIAL"><strong>Tutorial</strong></a></li>
      </ul>
    </nav>

    <!-- 右側：ページごとの本文 -->
    <main style="flex:1;min-width:0;">
      <h1 id="qubo-library-documantaion">QUBO++ Library Documantaion</h1>

<p><strong>QUBO (Quadratic Unconstrained Binary Optimization) models</strong> use quadratic functions over binary variables {0,1}.
<strong>HUBO</strong> (High-order Unconstrained Binary Optimization) generalizes QUBO to polynomial functions of arbitrary order.
The goal in QUBO/HUBO is to find a binary assignment that minimizes the objective.
<strong>QUBO++</strong> is a C++ model-and-solve library for modeling and solving QUBO/HUBO problems.
This document explains how to use QUBO++ to model QUBO and HUBO expressions and solve them.</p>

<h1 id="getting-started-hubo-expressions-and-the-qubo-library">Getting Started: HUBO Expressions and the QUBO++ Library</h1>

<p><strong>A HUBO (High-order Unconstrained Binary Optimization) expression</strong> is a polynomial in binary variables.
For example, consider three binary variables $a$, $b$ and $c$, and define</p>

\[\begin{aligned}
f(a,b,c)
&amp;=(a+b+c)(a+2b+3c-3)^2\\
&amp;= 9a +9b +9c -6a^2  -12b^2 -18c^2 -18ab -24ac -30bc  +a^3 +4b^3 +9c^3 +5a^2b +7a^2c +8ab^2 +15ac^2  +16b^2c +21bc^2 +22abc  \\
&amp;= 4a +b -5ab -2ac +7bc +22abc
\end{aligned}\]

<p>Expanding $(a+b+c)(a+2b+3c-3)^2$, we obtain an equivalent polynomial expression in the form of a sum of product terms.
Furthermore, using the fact that $x^2=x$ holds for all binary variables $x\in{0,1}$, we can merge equivalent terms to derive a simplified expression.
The resulting HUBO expression has:</p>
<ul>
  <li>constant term: none</li>
  <li>linear terms:  $4a$, $b$</li>
  <li>quadratic terms: $-5ab$, $-2ac$, $7bc$</li>
  <li>cubic term : $22acbc$</li>
</ul>

<p>In this document, we refer to $(a+b+c)(a+2b+3c-3)^2$ as <strong>a formula</strong>  (or HUBO formula) and
to the expanded, simplified polynomial $4a +b -5ab -2ac +7bc +22abc$ as <strong>an expression</strong> (or HUBO expression).
The resulting value of an expressoin, borrowing the terminology of quantum mechanics, is called <strong>the energy</strong>.
A HUBO problem aims to find a binary assignment of variables that minimizes this energy.
It should be clear that $f(a,b,c)$ achieves optimal energy 0 when $a+b+c=0$ or $a+2b+3c=3$.
Hence, it has three optimal solutions: $(a,b,c)=(0,0,0),(1,1,0),(0,0,1)$.</p>

<p><strong>QUBO++</strong> provides the following two main functionalities:
<strong>Model</strong>: symbolically derives expressions using C++ constructs.
<strong>Solve</strong>: finds solutions that minimize the energy of a given expression.
The following QUBO++ program models the polynomial expression for $f$ and enumerates all optimal solutions:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_exhaustive_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">exhaustive_solver</span><span class="o">::</span><span class="n">ExhaustiveSolver</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sols</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search_optimal_solutions</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sols</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The header <code class="language-plaintext highlighter-rouge">qbpp.hpp</code> enables use of the QUBO++ library, and <code class="language-plaintext highlighter-rouge">qbpp_exhaustive_solver.hpp</code> provides access to the Exhaustive Solver.
In this program, three variables, $a$, $b$, and $c$, are defined, along with the formula $f$.
The formula $f$ is automatically expanded, and the member function <code class="language-plaintext highlighter-rouge">simplify_as_binary()</code> 
applies the binary identity $x^2=x$ and merges equivalent terms to yield the simplified HUBO expression.
<strong>Ehaustive Solver</strong> then evaluates the energy of $f$ for all $2^3$ possible assignments, and outputs the optimal ones.
The output below confirms the HUBO expression and the four optimal solutions:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 4*a +b -5*a*b -2*a*c +7*b*c +22*a*b*c
(0) 0:{{a,0},{b,0},{c,0}}
(1) 0:{{a,0},{b,0},{c,1}}
(2) 0:{{a,1},{b,1},{c,0}}
</code></pre></div></div>

<p>As shown in this QUBO++ program, most QUBO++ objects can be displayed using <code class="language-plaintext highlighter-rouge">std::cout</code>, which makes debugging easier.</p>

<h1 id="qubo-core-classes">QUBO++ Core Classes</h1>
<p>The QUBO++ library provides the following core classes for designing polynomial expressions involving variables:</p>

<table>
  <thead>
    <tr>
      <th>Classes</th>
      <th>Role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>qbpp::Var</td>
      <td>Stores a single symbolic variable.</td>
    </tr>
    <tr>
      <td>qbpp::Expr</td>
      <td>Stores a polynomial expression of qbpp::Var objects.</td>
    </tr>
    <tr>
      <td>qbpp::Sol</td>
      <td>Stores a solution for qbpp::Expr objects.</td>
    </tr>
    <tr>
      <td>qbpp::VarInt</td>
      <td>Stores a set of qbpp::Var objects representing an integer.</td>
    </tr>
    <tr>
      <td>qbpp::Term</td>
      <td>Stores a single term included in qbpp::Expr objects.</td>
    </tr>
  </tbody>
</table>

<h1 id="qbppvar-class-variable-object">qbpp::Var class: Variable object</h1>

<h2 id="creating-qbppvar-objects">Creating qbpp::Var objects</h2>
<p><code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects can be created using <code class="language-plaintext highlighter-rouge">auto</code> type deduction and the <code class="language-plaintext highlighter-rouge">qbpp::var()</code> function.
A <code class="language-plaintext highlighter-rouge">qbpp::Var</code> object represents a single variable.
Unlike conventional programming languages, it does not store a variable’s value;
instead, it symbolically represents a variable within <code class="language-plaintext highlighter-rouge">qbpp::Term</code> and <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects.</p>

<p>We can use the <code class="language-plaintext highlighter-rouge">qbpp::var()</code> function to create a <code class="language-plaintext highlighter-rouge">qbpp::Var</code> object <code class="language-plaintext highlighter-rouge">a</code> that stores a variable with the name string  <code class="language-plaintext highlighter-rouge">a</code> as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
</code></pre></div></div>

<p>The argument <code class="language-plaintext highlighter-rouge">"a"</code> specifies the name string for the <code class="language-plaintext highlighter-rouge">qbpp::Var</code> object, which is used to represent the object as a string.
In this example, the variable is <code class="language-plaintext highlighter-rouge">qbpp::Var</code> <code class="language-plaintext highlighter-rouge">a</code> and its name is also <code class="language-plaintext highlighter-rouge">a</code>.
This name is mainly used when displaying expressions that contain the variable.
The name does not have to match the C++ variable identifier, although using the same string is recommended for clarity.
QUBO++ does not check that names are unique, so no error occurs even if the same name is used multiple times.</p>

<p>A vector of <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects can be defined with a specified size as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<p>This creates a vector <code class="language-plaintext highlighter-rouge">x</code> with three qbpp::Var objects with name <code class="language-plaintext highlighter-rouge">x</code>.
Each object can be accessed using <code class="language-plaintext highlighter-rouge">x[0]</code>, <code class="language-plaintext highlighter-rouge">x[1]</code>, and <code class="language-plaintext highlighter-rouge">x[2]</code>, and their name strings, <code class="language-plaintext highlighter-rouge">x[0]</code>, <code class="language-plaintext highlighter-rouge">x[1]</code>, and <code class="language-plaintext highlighter-rouge">x[2]</code>, combine the base name with the corresponding indices for display purposes.</p>

<p>Multi-dimensional <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects can be defined similarly.
For example, the following code creates a $3\times 2$ matrix <code class="language-plaintext highlighter-rouge">x</code> of <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"y"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<p>Each object can be accessed as <code class="language-plaintext highlighter-rouge">x[0][0]</code>, <code class="language-plaintext highlighter-rouge">x[0][1]</code>, <code class="language-plaintext highlighter-rouge">x[1][0]</code>, <code class="language-plaintext highlighter-rouge">x[1][1]</code>, <code class="language-plaintext highlighter-rouge">x[2][0]</code>, and <code class="language-plaintext highlighter-rouge">x[2][1]</code> and
they are displayed as <code class="language-plaintext highlighter-rouge">x[0][0]</code>, <code class="language-plaintext highlighter-rouge">x[0][1]</code>, <code class="language-plaintext highlighter-rouge">x[1][0]</code>, <code class="language-plaintext highlighter-rouge">x[1][1]</code>, <code class="language-plaintext highlighter-rouge">x[2][0]</code>, and <code class="language-plaintext highlighter-rouge">x[2][1]</code>.</p>

<p>Higher-dimensional <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects can be defined similarly, with no limitation on the number of dimensions.
Additionally, a variable can be created without specifying a name string:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">:</span><span class="n">var</span><span class="p">();</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">name</code> is omitted, default numbered names such as <code class="language-plaintext highlighter-rouge">{0}</code>, <code class="language-plaintext highlighter-rouge">{1}</code>, and so on are assigned.</p>

<h1 id="qbppexpr-class-expression-object">qbpp::Expr class: Expression object</h1>

<h2 id="creating-qbppexpr-objects">Creating qbpp::Expr objects</h2>
<p>A <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object stores a polynomial over <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects.
Expressions are built via overloaded arithmetic and compound-assignment operators with integers, including
<code class="language-plaintext highlighter-rouge">*</code> (multiplication), <code class="language-plaintext highlighter-rouge">+</code> (addition), <code class="language-plaintext highlighter-rouge">-</code> (subtraction / unary negation), <code class="language-plaintext highlighter-rouge">*=</code> (compound multiplication), <code class="language-plaintext highlighter-rouge">+=</code> (compound addition), and <code class="language-plaintext highlighter-rouge">-=</code> (compound subtraction).
You can also rely on type deduction with <code class="language-plaintext highlighter-rouge">auto</code> when assigning expressions:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">g</span> <span class="o">*=</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This program prints:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = -1 +x[0] -x[1] +x[0]*x[1]
g = -x[2] +x[0]*x[2] -x[1]*x[2] +x[0]*x[1]*x[2]
f = -1 +x[0]*x[1]
g = 0
</code></pre></div></div>
<p>It is straightforward to verify that the <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> correctly represent the intended expressions.</p>

<p>Please note that type deduction with <code class="language-plaintext highlighter-rouge">auto</code> does not work as intended when the right-hand side is an integer, a variable, or a product term.
For example, the following lines do not create <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects.
They create an <code class="language-plaintext highlighter-rouge">int</code>, a <code class="language-plaintext highlighter-rouge">qbpp::Var</code>, and a <code class="language-plaintext highlighter-rouge">qbpp::Term</code> respectively—none of which store an expression.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>
<p>Thus, the assignment below causes a compilation error because <code class="language-plaintext highlighter-rouge">g</code> is <strong>not</strong> a <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">g</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>To construct a <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> from non-expression values, use <code class="language-plaintext highlighter-rouge">qbpp::toExpr()</code>, which converts supported types to <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">toExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">toExpr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">toExpr</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="o">-</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">g</span> <span class="o">+=</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This QUBO++ program prints:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = x[0] -2*x[0]*x[1]*x[2]
g = x[0] +2*x[0]*x[1]*x[2]
</code></pre></div></div>
<p>Alternatively, declare the type explicitly:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">qbpp</span><span class="o">::</span><span class="n">Expr</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">Expr</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">Expr</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div></div>

<p>Arrays of <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> can be defined in the same way as arrays of <code class="language-plaintext highlighter-rouge">qbpp::Var</code>.
The following QUBO++ program creates arrays <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code>, each holding <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">expr</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Since <code class="language-plaintext highlighter-rouge">x</code> is an array of three <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects, <code class="language-plaintext highlighter-rouge">x + 1</code> performs an element-wise addition and returns an array of three <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects assigned to <code class="language-plaintext highlighter-rouge">f</code>.
<code class="language-plaintext highlighter-rouge">qbpp::expr(2)</code> creates an array <code class="language-plaintext highlighter-rouge">g</code> with two zero-initialized <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects, each capable of storing a HUBO expression.
This program assigns expressions to <code class="language-plaintext highlighter-rouge">g[0]</code> and <code class="language-plaintext highlighter-rouge">g[1]</code> and then prints:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{[0],1 +x[0]},{[1],1 +x[1]},{[2],1 +x[2]}
{[0],2 +x[0] +x[1] +x[2]},{[1],2*x[2] +2*x[1]*x[2]}
</code></pre></div></div>

<h1 id="qbppsol-class-solution-object">qbpp::Sol class: Solution object</h1>
<p>A qbpp::Sol object stores a solution to a HUBO problem—that is, an assignment of binary values to variables.
Below we illustrate it with the partition problem.</p>

<h2 id="partitioning-problem-and-the-qubo-formutation">Partitioning problem and the QUBO formutation.</h2>
<p>Let $N_0, N_1, \ldots, N_{n-1}$ be $n$ integers.
The goal is to split them into two subsets $L$ and $\overline{L}$ so that the two subset sums are as equal as possible.
Equivalently, we minimize</p>

\[\begin{aligned}
   f(L) &amp; = \left(\sum_{i\in L} N_i - \sum_{i\in\overline{L}}N_i\right)^2
\end{aligned}\]

<p>Introduce binary variable $x_0, x_1,\ldots, x_{n-1}$ where $x_i=1$ iff $i\in L$.
Then,</p>

\[\begin{aligned}
   \sum_{i\in L} N_i &amp; = \sum_{i=0}^{n-1} N_ix_i\\
   \sum_{i\in\overline{L}}N_i     &amp;= \sum_{i=0}^{n-1}N_i(1-x_i)
\end{aligned}\]

<p>so</p>

\[\begin{aligned}
   f(L) &amp; = \left(\sum_{i=0}^{n-1} N_ix_i - \sum_{i=0}^{n-1}N_i(1-x_i)\right)^2
        = \left(\sum_{i=0}^{n-1}N_i(1-2x_i)\right)^2
\end{aligned}\]

<p>Thus, minimizing this quadratic function over binary variables yields an optimal partition, i.e., a QUBO instance.
The following QUBO++ program builds the expression for $f(L)$ and finds a solution using the Easy Solver.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_easy_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">N</span> <span class="o">=</span> <span class="p">{</span><span class="mi">37</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">95</span><span class="p">};</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="n">N</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">toExpr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span> <span class="o">+=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">f</span> <span class="o">*=</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">easy_solver</span><span class="o">::</span><span class="n">EasySolver</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">time_limit</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"L :"</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sol</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~L: "</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sol</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">") "</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For the array of eight integers, this code constructs the quadratic objective $f$.
An EasySolver is created for <code class="language-plaintext highlighter-rouge">f</code>, its time limit is set to 1.0 s, and <code class="language-plaintext highlighter-rouge">search()</code> returns a solution stored in the <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> object <code class="language-plaintext highlighter-rouge">sol</code>.
Note that <code class="language-plaintext highlighter-rouge">sol(x[i])</code> returns the assigned value of <code class="language-plaintext highlighter-rouge">x[i]</code> in <code class="language-plaintext highlighter-rouge">sol</code>.</p>

<p>This program prints:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 228484 -65268*x[0] -129888*x[1] -105984*x[2] -98884*x[3] -38388*x[4] -118260*x[5] -81028*x[6] -145540*x[7] +24272*x[0]*x[1] +18944*x[0]*x[2] +17464*x[0]*x[3] +6216*x[0]*x[4] +21608*x[0]*x[5] +13912*x[0]*x[6] +28120*x[0]*x[7] +41984*x[1]*x[2] +38704*x[1]*x[3] +13776*x[1]*x[4] +47888*x[1]*x[5] +30832*x[1]*x[6] +62320*x[1]*x[7] +30208*x[2]*x[3] +10752*x[2]*x[4] +37376*x[2]*x[5] +24064*x[2]*x[6] +48640*x[2]*x[7] +9912*x[3]*x[4] +34456*x[3]*x[5] +22184*x[3]*x[6] +44840*x[3]*x[7] +12264*x[4]*x[5] +7896*x[4]*x[6] +15960*x[4]*x[7] +27448*x[5]*x[6] +55480*x[5]*x[7] +35720*x[6]*x[7]
sol = 0:{{x[0],1},{x[1],1},{x[2],0},{x[3],0},{x[4],0},{x[5],1},{x[6],1},{x[7],0}}
L : 37(0) 82(1) 73(5) 47(6)
~L: 64(2) 59(3) 21(4) 95(7) 
</code></pre></div></div>

<p>Since the energy of <code class="language-plaintext highlighter-rouge">sol</code> is 0, the instance is partitioned into two subsets with exactly equal sums.</p>

<h2 id="creating-qbppsol-objects-and-updating-assigned-binary-values">Creating qbpp::Sol objects and updating assigned binary values</h2>
<p>A <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> object is created associated with a fixed <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object, which cannot be changed.
It stores a solution: a mapping from <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects in the <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object to binary values (0/1).
Note that it is not necessary that a solution is not an optimal one.
The stored solution can be updated.</p>

<p>The following QUBO++ program creates an expression $f(a,b,c) = (a+2b+3c)^3$ and an associated solution using the <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> constructor, which creates a zero-initialized <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> object.
After that, the binary value assignment to qbpp::Var objects is updated by the <code class="language-plaintext highlighter-rouge">set()</code> member function.
The <code class="language-plaintext highlighter-rouge">set()</code> function accepts a <code class="language-plaintext highlighter-rouge">qbpp::Var</code> object with the binary value to be updated.
It also accepts a list of pairs of a <code class="language-plaintext highlighter-rouge">qbpp::Var</code> object and a binary value for batch updating.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">*=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">Sol</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"0: sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">sol</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1: sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">sol</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1: sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">sol</span><span class="p">.</span><span class="n">set</span><span class="p">({{</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">}});</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2: sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following output confirms that the assigned binary values and the resulting energy values are correct.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = a +8*b +27*c +18*a*b +36*a*c +90*b*c +36*a*b*c
0: sol = 0:{{a,0},{b,0},{c,0}}
1: sol = 1:{{a,1},{b,0},{c,0}}
1: sol = 64:{{a,1},{b,0},{c,1}}
2: sol = 125:{{a,0},{b,1},{c,1}}
</code></pre></div></div>

<p>Solvers bundled with QUBO++ provide member functions that search for a solution and return a <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> object containing the result. 
In typical usage, a <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> object is obtained this way.</p>

<h2 id="reading-the-value-of-binary-variables-and-the-energy">Reading the value of binary variables and the energy</h2>
<p>The binary value assigned to a <code class="language-plaintext highlighter-rouge">qbpp::Var</code> in a <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> can be obtained with the call <code class="language-plaintext highlighter-rouge">operator()</code>:
<code class="language-plaintext highlighter-rouge">sol(x)</code> returns 0 or 1 for that variable <code class="language-plaintext highlighter-rouge">x</code>.
A <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> also provides <code class="language-plaintext highlighter-rouge">energy()</code>, which returns the (cached) energy of the stored solution.
The call <code class="language-plaintext highlighter-rouge">operator()</code> of <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> also accepts a <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>: <code class="language-plaintext highlighter-rouge">sol(expr)</code> evaluates the expression under the current assignment.</p>

<p>The energy value in <code class="language-plaintext highlighter-rouge">qbpp::Sol</code> is cached lazily. When you change any variable via set(), the cached energy is invalidated.
To (re)compute and store the energy, call <code class="language-plaintext highlighter-rouge">comp_energy()</code>; subsequent calls to <code class="language-plaintext highlighter-rouge">energy()</code> will then return the cached value.</p>

<p>The example below defines three binary variables <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, builds two penalty expressions
$f = (a + b + c − 1)^2$ and $g = (a + 2b + 3c − 2)^2$, and combines them as $h = f + g$.
It then runs a simple solver to find a solution (targeting energy 0), prints the variable values and energies, flips a to 1 using <code class="language-plaintext highlighter-rouge">set()</code>, and demonstrates that the energy cache is invalidated and recomputed via <code class="language-plaintext highlighter-rouge">comp_energy()</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_easy_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"h = "</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">easy_solver</span><span class="o">::</span><span class="n">EasySolver</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">target_energy</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"h(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">.</span><span class="n">energy</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">sol</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"h(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">.</span><span class="n">comp_energy</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g(a,b,c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This program prints:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 1 -a -b -c +2*a*b +2*a*c +2*b*c
g = 4 -3*a -4*b -3*c +4*a*b +6*a*c +12*b*c
h = 5 -4*a -5*b -4*c +6*a*b +8*a*c +14*b*c
a = 0
b = 1
c = 0
h(a,b,c) = 0
f(a,b,c) = 0
g(a,b,c) = 0
a = 1
b = 1
c = 0
h(a,b,c) = 2
f(a,b,c) = 1
g(a,b,c) = 1
</code></pre></div></div>

<h1 id="qbppvarint-class-integer-class">qbpp::VarInt class: Integer class</h1>

<p>A <code class="language-plaintext highlighter-rouge">qbpp::VarInt</code> object is used to represent an integer value within a specified range.
It corresponds to a qbpp::Expr object composed of multiple <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects.
<code class="language-plaintext highlighter-rouge">qbpp::VarInt</code> objects can be created using the <code class="language-plaintext highlighter-rouge">qbpp::var_int()</code> global function.</p>

<p>A single <code class="language-plaintext highlighter-rouge">qbpp::VarInt object</code> <code class="language-plaintext highlighter-rouge">x</code>, representing an integer value in the range $[1,10]$, can be created and displayed with the following code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"x"</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>From the output of the code below, we can see that <code class="language-plaintext highlighter-rouge">x</code> is a qbpp::Expr object, composed of four qbpp::Var objects: <code class="language-plaintext highlighter-rouge">x[0]</code>, <code class="language-plaintext highlighter-rouge">x[1]</code>, <code class="language-plaintext highlighter-rouge">x[2]</code>, and <code class="language-plaintext highlighter-rouge">x[3]</code>, representing an integer value in the range $[1,10]$.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>The coefficients of the binary variables are determined based on the binary encoding of integers.
More specifically, to represent an integers $x$ in the range $[l,u]$ ($l&lt;u$), we use</p>

\[\begin{aligned}
   k &amp; = \lfloor \log_2(u-l+1)\rfloor
\end{aligned}\]

<p>binary variables, and express $x$ as</p>

\[\begin{aligned}
   x &amp; = l+2^0x_0+2^1x_1+\cdots 2^{k-2}x_{k-2}+cx_{k-1}
\end{aligned}\]

<p>where $c\in [1,2^{k-1}]$ s chosen so that</p>

\[\begin{aligned}
   u = l+2^0+2^1+\cdots 2^{k-2}+c
\end{aligned}\]

<p>holds.
The integers specifying the range can be negative.</p>

<p>Similarly to the creation of <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects, a multi-dimensional array of qbpp::VarInt objects with the same specified range can be created as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">"x"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>Each qbpp::VarInt object can be accessed by its indices, and the corresponding qbpp::Expr object can be displayed as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]},{</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span> <span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]}</span>
</code></pre></div></div>

<p>If a name string is not provided, default names such as <code class="language-plaintext highlighter-rouge">{0}</code>, <code class="language-plaintext highlighter-rouge">{1}</code>, and so on are assigned, similarly to <code class="language-plaintext highlighter-rouge">qbpp::Var</code> objects.</p>

<p>In most cases, <code class="language-plaintext highlighter-rouge">qbpp::VarInt</code> objects are implicitly converted to their corresponding <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects.</p>

<h1 id="operators-and-functions-for-qbppexpr">Operators and Functions for qbpp::Expr</h1>

<p>Operators and functions for <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> are divided into two categories: <strong>global functions</strong> and <strong>member functions</strong> as follows:</p>

<ul>
  <li><strong>Global functions</strong>: Take at least one <code class="language-plaintext highlighter-rouge">ExprType</code> object as an argument. In many cases, they return a <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object.</li>
  <li><strong>Member functions</strong>: Defined as member functions of the <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> class. In many cases, they update the calling object based on the result of the function.</li>
</ul>

<p>For example, the <code class="language-plaintext highlighter-rouge">sqr()</code> function, which computes the square of a qbpp::Expr object, is available as both a global and a member function.
The global version, <code class="language-plaintext highlighter-rouge">sqr(f)</code>, returns the square of <code class="language-plaintext highlighter-rouge">f</code> without updating <code class="language-plaintext highlighter-rouge">f</code>.
In contrast, the member function <code class="language-plaintext highlighter-rouge">f.sqr()</code> returns the square of <code class="language-plaintext highlighter-rouge">f</code> and updates <code class="language-plaintext highlighter-rouge">f</code> with this value.</p>

<p>The following table summarizes the available operators and functions:</p>

<table>
  <thead>
    <tr>
      <th>Operators/Functions</th>
      <th>Operator Symbols/Function Names</th>
      <th>Function Type</th>
      <th>Return Type</th>
      <th>Argument Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Type Conversion</td>
      <td>toExpr()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Type Conversion</td>
      <td>toInt()</td>
      <td>Global</td>
      <td>Int</td>
      <td>Expr</td>
    </tr>
    <tr>
      <td>Assignment</td>
      <td><code class="language-plaintext highlighter-rouge">=</code></td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Binary Operators</td>
      <td><code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code></td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType-ExprType</td>
    </tr>
    <tr>
      <td>Compound Assignment Operators</td>
      <td><code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code></td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Division</td>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType-Int</td>
    </tr>
    <tr>
      <td>Compound Division</td>
      <td><code class="language-plaintext highlighter-rouge">/=</code></td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>Int</td>
    </tr>
    <tr>
      <td>Unary Operators</td>
      <td><code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code></td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Comparison (Equality)</td>
      <td><code class="language-plaintext highlighter-rouge">==</code></td>
      <td>Global</td>
      <td>qbpp::ExprExpr</td>
      <td>ExprType-Int</td>
    </tr>
    <tr>
      <td>Comparison (Range Comparison)</td>
      <td><code class="language-plaintext highlighter-rouge">&lt;= &lt;=</code></td>
      <td>Global</td>
      <td>qbpp::ExprExpr</td>
      <td>IntInf-ExprType-IntInf</td>
    </tr>
    <tr>
      <td>Square</td>
      <td>sqr()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Square</td>
      <td>sqr()</td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>-</td>
    </tr>
    <tr>
      <td>GCD</td>
      <td>gcd()</td>
      <td>Global</td>
      <td>Int</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Simplify</td>
      <td>simplify(), simplify_as_binary(), simplify_as_spin()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Simplify</td>
      <td>simplify(), simplify_as_binary(), simplify_as_spin()</td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>-</td>
    </tr>
    <tr>
      <td>Eval</td>
      <td>eval()</td>
      <td>Global</td>
      <td>Int</td>
      <td>ExprType-MapList</td>
    </tr>
    <tr>
      <td>Eval</td>
      <td>operator()</td>
      <td>Member</td>
      <td>Int</td>
      <td>ExprType-MapList</td>
    </tr>
    <tr>
      <td>Replace</td>
      <td>replace()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType-MapList</td>
    </tr>
    <tr>
      <td>Replace</td>
      <td>replace()</td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>MapList</td>
    </tr>
    <tr>
      <td>Reduce</td>
      <td>reduce()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Reduce</td>
      <td>reduce()</td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>MapList</td>
    </tr>
    <tr>
      <td>Binary/Spin Conversion</td>
      <td>binary_to_spin(), spin_to_binary()</td>
      <td>Global</td>
      <td>qbpp::Expr</td>
      <td>ExprType</td>
    </tr>
    <tr>
      <td>Binary/Spin Conversion</td>
      <td>binary_to_spin(), spin_to_binary()</td>
      <td>Member</td>
      <td>qbpp::Expr</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p>In this table, <strong>Int</strong> denotes an integer, while <strong>IntInf</strong> represents either an integer, <code class="language-plaintext highlighter-rouge">-qbpp::inf</code>, or <code class="language-plaintext highlighter-rouge">+qbpp::inf</code>, which signify infinite values.
Additionally, <code class="language-plaintext highlighter-rouge">qbpp::ExprExpr</code> is a derived class of <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> that encapsulates another <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object.</p>

<h2 id="simplification-functions-for-qbppexpr">Simplification Functions for qbpp::Expr</h2>

<p>Simplification functions reduce expressions by sorting variables within terms, merging redundant terms, and ordering all terms. The following simplification functions are available:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">simplify()</code>: Sorts variables within terms, merges redundant terms, and orders all terms.</li>
  <li><code class="language-plaintext highlighter-rouge">simplify_as_binary()</code>: Simplifies expressions under the assumption that all variables take binary values ($0/1$), such that $x^2 = x$ for all variables $x$.</li>
  <li><code class="language-plaintext highlighter-rouge">simplify_as_spin()</code>: Simplifies expressions assuming all variables are spin variables ($-1/+1$), such that $x^2 = 1$ for all variables $x$.</li>
</ul>

<p>Therefore, after applying either <code class="language-plaintext highlighter-rouge">simplify_as_binary()</code> or <code class="language-plaintext highlighter-rouge">simplify_as_spin()</code>, no terms will contain duplicated variables.</p>

<p>The following example demonstrates how these functions are used and the differences in their outputs:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"qbpp::simplify(f) = "</span> <span class="o">&lt;&lt;</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"qbpp::simplify_as_binary(f) = "</span> <span class="o">&lt;&lt;</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">simplify_as_binary</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"qbpp::simplify_as_spin(f) = "</span> <span class="o">&lt;&lt;</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">simplify_as_spin</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The output of this code will display the simplified expressions as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">b</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">b</span> <span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">b</span>
<span class="n">qbpp</span><span class="o">::</span><span class="n">simplify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">b</span>
<span class="n">qbpp</span><span class="o">::</span><span class="n">simplify_as_binary</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">b</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="n">qbpp</span><span class="o">::</span><span class="n">simplify_as_spin</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
</code></pre></div></div>

<p>Variables within terms are ordered so that earlier-defined variables appear first.
Additionally, lower-degree terms appear before higher-degree terms.
For terms of the same degree, lexicographically earlier terms are prioritized.</p>

<h2 id="comparison-operators-for-qbppexpr">Comparison Operators for qbpp::Expr</h2>

<p>Comparison operators, equality (<code class="language-plaintext highlighter-rouge">==</code>), and range comparison (<code class="language-plaintext highlighter-rouge">&lt;= &lt;=</code>) are supported between <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> objects and integers.
In addition to integers, infinite values represented as <code class="language-plaintext highlighter-rouge">+qbpp::inf</code> and <code class="language-plaintext highlighter-rouge">-qbpp::inf</code> can also be specified.</p>
<ul>
  <li>Expr <code class="language-plaintext highlighter-rouge">==</code> Int: Returns a qbpp::Expr object that evaluates to a minimum value of 0 if the equality is satisfied.</li>
  <li>IntInf <code class="language-plaintext highlighter-rouge">&lt;=</code> Expr <code class="language-plaintext highlighter-rouge">&lt;=</code> IntInf: Returns a qbpp::Expr object that evaluates to a minimum value of 0 if the range comparison is satisfied.</li>
</ul>

<p>Single inequalities are intentionally not supported to prevent potential misuse caused by misunderstandings.
Instead, <code class="language-plaintext highlighter-rouge">qbpp::inf</code> can be used to represent single inequalities. Specifically:</p>
<ul>
  <li>Int <code class="language-plaintext highlighter-rouge">&lt;=</code> Expr can be expressed as Int <code class="language-plaintext highlighter-rouge">&lt;=</code> Expr <code class="language-plaintext highlighter-rouge">&lt;=</code> <code class="language-plaintext highlighter-rouge">+qbpp::inf</code>, and</li>
  <li>Expr <code class="language-plaintext highlighter-rouge">&lt;=</code> Int can be expressed as <code class="language-plaintext highlighter-rouge">-qbpp::inf</code> <code class="language-plaintext highlighter-rouge">&lt;=</code> Expr <code class="language-plaintext highlighter-rouge">&lt;=</code> Int.</li>
</ul>

<p>Other comparison operators such as !=, &lt;, &gt;=, and &gt; are not supported.</p>

<h3 id="example-of-equality">Example of Equality</h3>
<p>As an example of using equality operators, we present a QUBO++ program that solves the following linear equations:</p>

\[\begin{aligned}
x + y &amp;= 10 \\
2x+4y &amp;= 24 
\end{aligned}\]

<p>The following code demonstrates how to solve these linear equations using the Exhaustive Solver:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_exhaustive_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"x"</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"y"</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">24</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span>
  <span class="n">h</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">exhaustive_solver</span><span class="o">::</span><span class="n">ExhaustiveSolver</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sol = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*f = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*g = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this code, <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> are instances of the <code class="language-plaintext highlighter-rouge">qbpp::ExprExpr</code> class, which is derived from <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>.
The base class stores a QUBO expression that attains a minimum value of 0 when the equalities hold.
Additionally, the derived class contains another <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object representing the QUBO expression on the left-hand side of the equality.
This additional <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object can be accessed using the <code class="language-plaintext highlighter-rouge">operator*</code>, meaning that <code class="language-plaintext highlighter-rouge">*f</code> and <code class="language-plaintext highlighter-rouge">*g</code> return the QUBO expression on the left-hand side.</p>

<p>The output below confirms that the correct solution to the linear equations is obtained:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sol = 0:{{x[0],1},{x[1],0},{x[2],1},{x[3],1},{y[0],0},{y[1],1},{y[2],0},{y[3],0}}
x = 8
y = 2
*f = x[0] +2*x[1] +4*x[2] +3*x[3] +y[0] +2*y[1] +4*y[2] +3*y[3] = 10
*g = 2*x[0] +4*x[1] +8*x[2] +6*x[3] +4*y[0] +8*y[1] +16*y[2] +12*y[3] = 24
f = 100 +x[0]*x[0] +2*x[1]*x[0] +4*x[2]*x[0] +3*x[3]*x[0] +y[0]*x[0] +2*y[1]*x[0] +4*y[2]*x[0] +3*y[3]*x[0] +2*x[0]*x[1] +4*x[1]*x[1] +8*x[2]*x[1] +6*x[3]*x[1] +2*y[0]*x[1] +4*y[1]*x[1] +8*y[2]*x[1] +6*y[3]*x[1] +4*x[0]*x[2] +8*x[1]*x[2] +16*x[2]*x[2] +12*x[3]*x[2] +4*y[0]*x[2] +8*y[1]*x[2] +16*y[2]*x[2] +12*y[3]*x[2] +3*x[0]*x[3] +6*x[1]*x[3] +12*x[2]*x[3] +9*x[3]*x[3] +3*y[0]*x[3] +6*y[1]*x[3] +12*y[2]*x[3] +9*y[3]*x[3] +x[0]*y[0] +2*x[1]*y[0] +4*x[2]*y[0] +3*x[3]*y[0] +y[0]*y[0] +2*y[1]*y[0] +4*y[2]*y[0] +3*y[3]*y[0] +2*x[0]*y[1] +4*x[1]*y[1] +8*x[2]*y[1] +6*x[3]*y[1] +2*y[0]*y[1] +4*y[1]*y[1] +8*y[2]*y[1] +6*y[3]*y[1] +4*x[0]*y[2] +8*x[1]*y[2] +16*x[2]*y[2] +12*x[3]*y[2] +4*y[0]*y[2] +8*y[1]*y[2] +16*y[2]*y[2] +12*y[3]*y[2] +3*x[0]*y[3] +6*x[1]*y[3] +12*x[2]*y[3] +9*x[3]*y[3] +3*y[0]*y[3] +6*y[1]*y[3] +12*y[2]*y[3] +9*y[3]*y[3] -10*x[0] -20*x[1] -40*x[2] -30*x[3] -10*y[0] -20*y[1] -40*y[2] -30*y[3] -10*x[0] -20*x[1] -40*x[2] -30*x[3] -10*y[0] -20*y[1] -40*y[2] -30*y[3] = 0
g = 576 +4*x[0]*x[0] +8*x[1]*x[0] +16*x[2]*x[0] +12*x[3]*x[0] +8*y[0]*x[0] +16*y[1]*x[0] +32*y[2]*x[0] +24*y[3]*x[0] +8*x[0]*x[1] +16*x[1]*x[1] +32*x[2]*x[1] +24*x[3]*x[1] +16*y[0]*x[1] +32*y[1]*x[1] +64*y[2]*x[1] +48*y[3]*x[1] +16*x[0]*x[2] +32*x[1]*x[2] +64*x[2]*x[2] +48*x[3]*x[2] +32*y[0]*x[2] +64*y[1]*x[2] +128*y[2]*x[2] +96*y[3]*x[2] +12*x[0]*x[3] +24*x[1]*x[3] +48*x[2]*x[3] +36*x[3]*x[3] +24*y[0]*x[3] +48*y[1]*x[3] +96*y[2]*x[3] +72*y[3]*x[3] +8*x[0]*y[0] +16*x[1]*y[0] +32*x[2]*y[0] +24*x[3]*y[0] +16*y[0]*y[0] +32*y[1]*y[0] +64*y[2]*y[0] +48*y[3]*y[0] +16*x[0]*y[1] +32*x[1]*y[1] +64*x[2]*y[1] +48*x[3]*y[1] +32*y[0]*y[1] +64*y[1]*y[1] +128*y[2]*y[1] +96*y[3]*y[1] +32*x[0]*y[2] +64*x[1]*y[2] +128*x[2]*y[2] +96*x[3]*y[2] +64*y[0]*y[2] +128*y[1]*y[2] +256*y[2]*y[2] +192*y[3]*y[2] +24*x[0]*y[3] +48*x[1]*y[3] +96*x[2]*y[3] +72*x[3]*y[3] +48*y[0]*y[3] +96*y[1]*y[3] +192*y[2]*y[3] +144*y[3]*y[3] -48*x[0] -96*x[1] -192*x[2] -144*x[3] -96*y[0] -192*y[1] -384*y[2] -288*y[3] -48*x[0] -96*x[1] -192*x[2] -144*x[3] -96*y[0] -192*y[1] -384*y[2] -288*y[3] = 0
</code></pre></div></div>

<h3 id="example-of-inequality">Example of Inequality</h3>

<p>The following code computes qbpp::Expr object <code class="language-plaintext highlighter-rouge">f</code> that takes minimum value of 0 if
$
2\leq a+2b+3c +4d\leq 4
$
is satisfied and finds all optimal solutions:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_exhaustive_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"d"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*f = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">exhaustive_solver</span><span class="o">::</span><span class="n">ExhaustiveSolver</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sols</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search_optimal_solutions</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">sol</span> <span class="o">:</span> <span class="n">sols</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="s">" *f = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The output of this code is as follows:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 6 -4*a -6*b -6*c -4*d +6*{0} +4*a*b +6*a*c +8*a*d -2*a*{0} +12*b*c +16*b*d -4*b*{0} +24*c*d -6*c*{0} -8*d*{0}
*f = a +2*b +3*c +4*d
0:{{a,0},{b,0},{c,0},{d,1},{{0},1}} *f = 4
0:{{a,0},{b,0},{c,1},{d,0},{{0},0}} *f = 3
0:{{a,0},{b,0},{c,1},{d,0},{{0},1}} *f = 3
0:{{a,0},{b,1},{c,0},{d,0},{{0},0}} *f = 2
0:{{a,1},{b,0},{c,1},{d,0},{{0},1}} *f = 4
0:{{a,1},{b,1},{c,0},{d,0},{{0},0}} *f = 3
0:{{a,1},{b,1},{c,0},{d,0},{{0},1}} *f = 3
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">{0}</code> is an auxiliary variable required to implement the range comparison.
We can confirm that the output includes all solutions that satisfy the range comparison.</p>

<p>The following code computes qbpp::Expr object <code class="language-plaintext highlighter-rouge">f</code> that takes minimum value of 0 if
$
8\leq a+2b+3c +4d
$
is satisfied and finds all optimal solutions:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_exhaustive_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"d"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">inf</span><span class="p">;</span>
  <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*f = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">exhaustive_solver</span><span class="o">::</span><span class="n">ExhaustiveSolver</span> <span class="n">solver</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sols</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search_optimal_solutions</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">sol</span> <span class="o">:</span> <span class="n">sols</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span> <span class="o">&lt;&lt;</span> <span class="s">" *f = "</span> <span class="o">&lt;&lt;</span> <span class="n">sol</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this code, <code class="language-plaintext highlighter-rouge">qbpp::inf</code> is used to indicate that the range comparison has no upper bound.
The output of this code is as follows:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 72 -16*a -30*b -42*c -52*d +18*{0} +4*a*b +6*a*c +8*a*d -2*a*{0} +12*b*c +16*b*d -4*b*{0} +24*c*d -6*c*{0} -8*d*{0}
*f = a +2*b +3*c +4*d
0:{{a,0},{b,1},{c,1},{d,1},{{0},0}} *f = 9
0:{{a,0},{b,1},{c,1},{d,1},{{0},1}} *f = 9
0:{{a,1},{b,0},{c,1},{d,1},{{0},0}} *f = 8
0:{{a,1},{b,1},{c,1},{d,1},{{0},1}} *f = 10
</code></pre></div></div>

<p>We can confirm that the output includes all solutions that satisfy the range comparison.</p>

<h2 id="evaluation-functions-for-qbppexpr">Evaluation Functions for qbpp::Expr</h2>

<p>Given a mapping of variables to integer values, the evaluation function computes the energy of a qbpp::Expr.
This mapping must include all variables present in the qbpp::Expr and should be provided as a qbpp::MapList object, which is a list of pairs consisting of qbpp::Var objects and corresponding integer values.
The following code demonstrates how to use the evaluation functions with a qbpp::MapList object:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">MapList</span> <span class="n">var_map</span> <span class="o">=</span> <span class="p">{{</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(0, 0, 0) = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="n">var_map</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(0, 1, 0) = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">({{</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">}})</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this code, the energy value of <code class="language-plaintext highlighter-rouge">f</code> is evaluated using a qbpp::MapList object, <code class="language-plaintext highlighter-rouge">var_map</code>.
The energy is also evaluated for a set of values provided using an initializer list.
The expected output of the code is as follows:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 3 -2*a -3*b -3*c +2*a*b +3*a*c +6*b*c
f(0, 0, 0) = 3
f(0, 1, 0) = 0
</code></pre></div></div>

<h2 id="replacement-functions-for-qbppexpr">Replacement Functions for qbpp::Expr</h2>

<p>The replacement functions substitute qbpp::Var and qbpp::VarInt objects in qbpp::Expr objects with other qbpp::Expr objects.
Since a qbpp::Expr object can also store integers, variables can be replaced with integers as well.
The mapping of qbpp::Var objects to qbpp::Expr objects is defined using qbpp::MapList objects.
Unlike evaluation functions, it is not necessary to define mappings for all variables.</p>

<p>The following code demonstrates how to use replacement functions to replace variables:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">).</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">qbpp</span><span class="o">::</span><span class="n">MapList</span> <span class="n">var_map</span> <span class="o">=</span> <span class="p">{{</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(0, c-1, c) = "</span> <span class="o">&lt;&lt;</span> <span class="n">replace</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">var_map</span><span class="p">).</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this code, the energy value of <code class="language-plaintext highlighter-rouge">f</code> is evaluated using a qbpp::MapList object, <code class="language-plaintext highlighter-rouge">var_map</code>.
The energy is also evaluated for a set of values provided using an initializer list.
The expected output of the code is as follows:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 3 -2*a -3*b -3*c +2*a*b +3*a*c +6*b*c
f(0, c-1, c) = 6 -6*c
</code></pre></div></div>

<p>The eval() and replace() functions can be used with qbpp::MapList objects and qbpp::VarInt objects, as demonstrated in the following example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var_int</span><span class="p">(</span><span class="s">"b"</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(2, b) = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">replace</span><span class="p">({{</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">}}).</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f(2, 1) = "</span> <span class="o">&lt;&lt;</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">eval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">{{</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">}})</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Based on the following output, we can confirm that the functions are working correctly:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = a[0] +4*a[1] +4*a[2] -b[0] -4*b[1] -4*b[2] +4*a[0]*a[1] +4*a[0]*a[2] +8*a[1]*a[2] -4*b[0]*b[1] -4*b[0]*b[2] -8*b[1]*b[2]
f(2, b) = 4 -b[0] -4*b[1] -4*b[2] -4*b[0]*b[1] -4*b[0]*b[2] -8*b[1]*b[2]
f(2, 1) = 3
</code></pre></div></div>

<p>Since the replacement function involves intensive computation, repeated applications should be avoided.
When replacing multiple variables, a single MapList object defining all replacements should be created, and the replacement function should be called only once for this MapList object.
Alternatively, individual MapList objects can be created for each replacement, and the replacement function can be called repeatedly for each one to achieve the same result.
However, this repeated execution of the replacement function is computationally expensive and should be avoided.</p>

<h2 id="reduction-functions-for-qbppexpr">Reduction Functions for qbpp::Expr</h2>

<p>The reduction function reduces the degree of all terms in qbpp::Expr objects to two, in order to obtain QUBO expressions.
The reduction is performed using auxiliary variables, ensuring that the optimal solutions remain unchanged.</p>

<p>The following code demonstrates the reduction of the degree-3 expression $+abc$:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
#include</span> <span class="cpf">"qbpp_exhaustive_solver.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g = "</span> <span class="o">&lt;&lt;</span> <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">exhaustive_solver</span><span class="o">::</span><span class="n">ExhaustiveSolver</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">sol_all</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">search_all_solutions</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sol_all</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code uses the ExhaustiveSolver to evaluate all possible solutions, producing the following output:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = a*b*c
g = {0} +a*b +a*c -a*{0} +b*c -b*{0} -c*{0}
0:0:{{a,0},{b,0},{c,0},{{0},0}}
1:0:{{a,0},{b,0},{c,1},{{0},0}}
2:0:{{a,0},{b,0},{c,1},{{0},1}}
3:0:{{a,0},{b,1},{c,0},{{0},0}}
4:0:{{a,0},{b,1},{c,0},{{0},1}}
5:0:{{a,0},{b,1},{c,1},{{0},1}}
6:0:{{a,1},{b,0},{c,0},{{0},0}}
7:0:{{a,1},{b,0},{c,0},{{0},1}}
8:0:{{a,1},{b,0},{c,1},{{0},1}}
9:0:{{a,1},{b,1},{c,0},{{0},1}}
10:1:{{a,0},{b,0},{c,0},{{0},1}}
11:1:{{a,0},{b,1},{c,1},{{0},0}}
12:1:{{a,1},{b,0},{c,1},{{0},0}}
13:1:{{a,1},{b,1},{c,0},{{0},0}}
14:1:{{a,1},{b,1},{c,1},{{0},1}}
15:3:{{a,1},{b,1},{c,1},{{0},0}}
</code></pre></div></div>

<p>The auxiliary variable, shown as <code class="language-plaintext highlighter-rouge">{0}</code> is introduced to ensure the equivalent QUBO expression.
From the result of the ExhaustiveSolver, we can confirm that $g=1$ when
$a=b=c=1$, and that $g$ can take minimum value of 0 otherwise.
Thus, $g$ and $f=abc$ are equivalent.</p>

    </main>
  </div>
</body>

</html>