<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>QUBO++ Documentation - QUBO++</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- ここで relative_url を本当に使う -->
  <link rel="stylesheet" href="/assets/main.css">

  <!-- ここに MathJax 関連をまとめて入れる -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


<body>
  <div style="display:flex; align-items:flex-start; gap:2rem; padding:1rem;">

    <!-- 左ナビ（全ページ共通） -->
    <nav style="min-width:220px; position:sticky; top:1rem; padding-right:1rem; border-right:1px solid #ddd;">
      <h2>QUBO++<br> Information</h2>
      <ul class="nav-large" style="list-style:none; padding-left:0;">
        <li><a href="https://github.com/nakanocs/qbpp/releases"><strong>Releases</strong></a></li>
        <li><a href="/DOCUMENT"><strong>Document</strong></a></li>
        <li><a href="/tutorial/TUTORIAL"><strong>Tutorial</strong></a></li>
      </ul>
    </nav>

    <!-- 右側：ページごとの本文 -->
    <main style="flex:1;min-width:0;">
      <h1 id="defining-variables-and-expressions">Defining Variables and Expressions</h1>

<h2 id="header-file-and-namespace">Header file and namespace</h2>
<p>To use QUBO++, you need to include the header file <code class="language-plaintext highlighter-rouge">qbpp.hpp</code> and use the <code class="language-plaintext highlighter-rouge">qbpp</code> namespace.</p>

<h2 id="defining-variables-and-expressions-1">Defining variables and expressions</h2>
<p>You can define a variable using <code class="language-plaintext highlighter-rouge">qbpp::var("name")</code> with auto type deduction.
The specified <code class="language-plaintext highlighter-rouge">name</code> is used when the variable is printed with <code class="language-plaintext highlighter-rouge">std::cout</code>.</p>

<p>Expressions are constructed using standard arithmetic operators such as <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, and <code class="language-plaintext highlighter-rouge">*</code>.</p>

<p>The following sample program defines three variables <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, and an expression <code class="language-plaintext highlighter-rouge">f</code>, which is printed using <code class="language-plaintext highlighter-rouge">std::cout</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"qbpp.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">qbpp</span><span class="o">::</span><span class="n">var</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The expression <code class="language-plaintext highlighter-rouge">(a + b - 1) * (b + c - 1)</code> is automatically expanded and stored in <code class="language-plaintext highlighter-rouge">f</code>.</p>

<p>In this QUBO++ program, the variables <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code> are objects of class <code class="language-plaintext highlighter-rouge">qbpp::Var</code>, and the expression <code class="language-plaintext highlighter-rouge">f</code> is an object of class <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>.</p>

<p>Assuming the header and library paths are properly set up, this program (saved as <code class="language-plaintext highlighter-rouge">test.cpp</code>) can be compiled with <code class="language-plaintext highlighter-rouge">g++</code> as follows:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>g++ test.cpp <span class="nt">-o</span> <span class="nb">test</span>
</code></pre></div></div>
<p>Running the executable prints the expanded expression:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test
f <span class="o">=</span> 1 +a<span class="k">*</span>b +b<span class="k">*</span>b +a<span class="k">*</span>c +b<span class="k">*</span>c <span class="nt">-a</span> <span class="nt">-b</span> <span class="nt">-b</span> <span class="nt">-c</span>
</code></pre></div></div>

<blockquote>
  <p><strong>NOTE</strong>
The variable name in <code class="language-plaintext highlighter-rouge">qbpp::var()</code> may be omitted.
If omitted, a default name such as <code class="language-plaintext highlighter-rouge">{0}</code>, <code class="language-plaintext highlighter-rouge">{1}</code>,… is automatically assigned.</p>
</blockquote>

<blockquote>
  <p><strong>WARNING</strong>
Most QUBO++ class instances, such as <code class="language-plaintext highlighter-rouge">qbpp::Expr</code>, can be printed as text using <code class="language-plaintext highlighter-rouge">std::cout</code>.
However, this textual output is not guaranteed to be stable and should not be used as input for subsequent computations, since its format may change in future releases.
In addition, the output shown in this tutorial may have been generated with an older version of QUBO++, so the output produced by the latest version may differ.</p>
</blockquote>

<h2 id="simplifying-expression">Simplifying expression</h2>
<p>The expression stored in a <code class="language-plaintext highlighter-rouge">qbpp::Expr</code> object can be simplified by calling the <code class="language-plaintext highlighter-rouge">simplify()</code> member function:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>
<p>With this change, the output of the program becomes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f.simplify() = 1 -a -2*b -c +a*b +a*c +b*b +b*c
</code></pre></div></div>
<p>The member function call <code class="language-plaintext highlighter-rouge">f.simplify()</code> simplifies the expression <code class="language-plaintext highlighter-rouge">f</code> and returns the resulting value,
which is then printed by <code class="language-plaintext highlighter-rouge">std::cout</code>.</p>

<p>Assuming that all variables take binary values (0 or 1), we can use the identity 
$b^2=b$ to further simplify the expression.
For this purpose, we use <code class="language-plaintext highlighter-rouge">simplify_as_binary()</code> instead:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_binary</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>
<p>Then the output becomes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 1 -a -b -c +a*b +a*c +b*c
</code></pre></div></div>

<p>The simplify functions reorder the variables within each term and the terms within the expression so that lower-degree terms appear first, and terms of the same degree are sorted in the lexicographical order of their variables.
The variables themselves are ordered according to the order in which they were defined.</p>

<h2 id="simplifying-expressions-with-spin-variables">Simplifying expressions with spin variables</h2>
<p>If variables are assumed to take spin values $-1$/$+1$, the identity $b^2 = 1$ can be used to further simplify the expression.
In this case, the expression can be simplified using the <code class="language-plaintext highlighter-rouge">simplify_as_spin()</code> member function:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f = "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">simplify_as_spin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>
<p>Then the output becomes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 2 -a -2*b -c +a*b +a*c +b*c
</code></pre></div></div>

<h2 id="global-functions-for-simplification">Global functions for simplification</h2>
<p>Member functions update the expression stored in <code class="language-plaintext highlighter-rouge">f</code>.
If you do not want to modify <code class="language-plaintext highlighter-rouge">f</code>, you can instead use the global functions
<code class="language-plaintext highlighter-rouge">qbpp::simplify(f)</code>, <code class="language-plaintext highlighter-rouge">qbpp::simplify_as_binary(f)</code>, and <code class="language-plaintext highlighter-rouge">qbpp::simplify_as_spin(f)</code>, which return the simplified expressions without changing <code class="language-plaintext highlighter-rouge">f</code>.</p>

<blockquote>
  <p><strong>NOTE</strong>
In QUBO++, most member functions update the object in place when possible, whereas global functions return a new value without modifying the original object.</p>
</blockquote>

    </main>
  </div>
</body>

</html>